#!/bin/bash
set -euo pipefail

UPDATE_URL="https://github.com/wlritchi/env"

# find remote for non-interactive updates
update_remote=
while IFS= read remote; do
    if [ "$(git -C "$WLR_ENV_PATH" remote get-url "$remote")" == "https://github.com/wlritchi/env" ]; then
        update_remote="$remote"
        break
    fi
done < <( git -C "$WLR_ENV_PATH" remote )

if [ -z "$update_remote" ]; then
    git -C "$WLR_ENV_PATH" remote add updates "$UPDATE_URL"
    update_remote=updates
fi

git -C "$WLR_ENV_PATH" fetch "$update_remote"
local_commit="$(git -C "$WLR_ENV_PATH" rev-parse HEAD)"
remote_commit="$(git -C "$WLR_ENV_PATH" rev-parse "$update_remote/main")"

# check signature
if ! "$WLR_ENV_PATH/bin/crypto/git-gpg-self" -C "$WLR_ENV_PATH" verify-commit "$remote_commit"; then
    printf 'Error: rejected signature.
' >&2
    exit 1
fi

# if nothing to do, exit early
if [ "$local_commit" == "$remote_commit" ]; then
    exit 0
fi

git -C "$WLR_ENV_PATH" merge --ff-only "$remote_commit"

# check for new symlinks in dotfiles

sync_dir() {
    local parent="${1%/*}"
    if [ "$parent" != "$relative" ]; then
        sync_dir "$parent"
    fi
    if [ -d "$HOME/$1" ]; then
        expected_permissions="$(stat -c '%a' "$WLR_ENV_PATH/dotfiles/$1")"
        actual_permissions="$(stat -c '%a' "$HOME/$1")"
        if [ "$expected_permissions" != "$actual_permissions" ]; then
            printf 'Warning: permissions on %s/%s are %s (expected %s)
' "$HOME" "$1" "$actual_permissions" "$expected_permissions" >&2
        fi
    elif [ -e "$HOME/$1" ]; then
        printf 'Error: %s/%s exists, but is not a directory
' "$HOME" "$1" >&2
    else
        cp -r "$WLR_ENV_PATH/dotfiles/$1" "$HOME/$1"
    fi
}

link_file() {
    if [ -L "$HOME/$1" ]; then
        expected_target="$(realpath "$WLR_ENV_PATH/dotfiles/$1")"
        actual_target="$(realpath "$HOME/$1")"
        if [ "$expected_target" != "$actual_target" ]; then
            printf 'Error: %s/%s is symlinked to %s (expected %s)
' "$HOME" "$1" "$actual_target" "$expected_target" >&2
        fi
    elif [ -f "$HOME/$1" ]; then
        printf 'Error: %s/%s exists, but is a regular file
' "$HOME" "$1" >&2
    elif [ -e "$HOME/$1" ]; then
        printf 'Error: %s/%s exists, but is not a regular file or symlink
' "$HOME" "$1" >&2
    else
        ln -s "$(realpath "$WLR_ENV_PATH/dotfiles/$1")" "$HOME/$1"
    fi
}

while IFS= read filename; do
    relative="${filename#"$WLR_ENV_PATH/dotfiles/"}"
    if [ "$relative" == "$filename" ]; then
        printf 'Error: failed to match filename %s against expected subdirectory\n' "$filename"
        continue
    fi
    dir="${relative%/*}"
    if [ "$dir" != "$relative" ]; then
        sync_dir "$dir"
    fi
    link_file "$relative"
done < <( find "$WLR_ENV_PATH/dotfiles/" -type f 2>/dev/null || true )
