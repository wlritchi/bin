#!/bin/bash
set -euo pipefail

# exit code:
#   zero for success requiring re-executing the environment
#   nonzero for skipped/no-op update or error

UPDATE_URL="https://github.com/wlritchi/env"

force=
[ "${1:-}" == '--force' ] && force=y

if [ -z "$force" ]; then
    if [ -e "$WLR_ENV_PATH/meta/.last-update-check" ] && [ -z "$(find "$WLR_ENV_PATH/meta/.last-update-check" -mmin +60 -print -quit)" ]; then
        wlr-good 'update check skipped'
        exit 1
    fi
fi

wlr-working 'update check'

# find remote for non-interactive updates
update_remote=
while IFS= read remote <&3; do
    if [ "$(git -C "$WLR_ENV_PATH" remote get-url "$remote")" == "https://github.com/wlritchi/env" ]; then
        update_remote="$remote"
        break
    fi
done 3< <( git -C "$WLR_ENV_PATH" remote )

if [ -z "$update_remote" ]; then
    git -C "$WLR_ENV_PATH" remote add updates "$UPDATE_URL"
    update_remote=updates
fi

git -C "$WLR_ENV_PATH" fetch "$update_remote"
local_commit="$(git -C "$WLR_ENV_PATH" rev-parse HEAD)"
remote_commit="$(git -C "$WLR_ENV_PATH" rev-parse "$update_remote/main")"

# if nothing to do, exit early
if [ -z "$force" ]; then
    if [ "$local_commit" == "$remote_commit" ]; then
        wlr-good 'update check succeeded, no new changes'
        touch "$WLR_ENV_PATH/meta/.last-update-check"
        exit 1
    fi
fi

# check signature
if ! "$WLR_ENV_PATH/bin/crypto/git-gpg-self" -C "$WLR_ENV_PATH" verify-commit "$remote_commit"; then
    wlr-error 'update failed, bad signature'
    exit 1
fi

git -C "$WLR_ENV_PATH" merge --ff-only "$remote_commit"

# check for new symlinks in dotfiles

print_diff() {
    if command -v colordiff >/dev/null 2>&1; then
        colordiff "$@" || true
    else
        diff "$@" || true
    fi
}

get_permissions() {
    if stat --version 2>/dev/null | grep -q GNU; then
        stat -c '%a' "$1" # GNU coreutils
    else
        stat -f '%A' "$1" # macOS, BSD
    fi
}

sync_dir() {
    local parent="${1%/*}"
    if [ "$parent" != "$1" ]; then
        sync_dir "$parent" || return 1
    fi
    if [ -d "$HOME/$1" ]; then
        if [ -L "$HOME/$1" ]; then
            target="$(realpath "$HOME/$1")"
            wlr-warn "update: $HOME/$1 is a directory symlink to $target"
            if wlr-ask "Replace with directory and copy contents of original target?"; then
                rm "$HOME/$1"
                cp -rp "$target" "$HOME/$1"
                return
            fi
            return 1
        fi
    elif [ -e "$HOME/$1" ]; then
        wlr-warn "update: $HOME/$1 exists, but is not a directory"
        return 1
    else
        mkdir -p "$HOME/$1"
    fi
}

link_file() {
    if [ -L "$HOME/$1" ]; then
        expected_target="$(realpath "$WLR_ENV_PATH/dotfiles/$1")"
        actual_target="$(realpath "$HOME/$1")"
        if [ "$expected_target" != "$actual_target" ]; then
            print_diff "$HOME/$1" "$WLR_ENV_PATH/dotfiles/$1"
            if wlr-ask "Update symlink $HOME/$1 to point to $WLR_ENV_PATH/dotfiles/$1 (currently $actual_target)?"; then
                ln -sf "$WLR_ENV_PATH/dotfiles/$1" "$HOME/$1"
            fi
        fi
    elif [ -f "$HOME/$1" ]; then
        print_diff "$HOME/$1" "$WLR_ENV_PATH/dotfiles/$1"
        if wlr-ask "Replace $HOME/$1 with a symlink to $WLR_ENV_PATH/dotfiles/$1?"; then
            ln -sf "$WLR_ENV_PATH/dotfiles/$1" "$HOME/$1"
        fi
    elif [ -e "$HOME/$1" ]; then
        wlr-warn "update: $HOME/$1 exists, but is not a regular file or symlink"
        return 1
    else
        ln -s "$(realpath "$WLR_ENV_PATH/dotfiles/$1")" "$HOME/$1"
    fi
}

while IFS= read filename <&3; do
    relative="${filename#"$WLR_ENV_PATH/dotfiles/"}"
    if [ "$relative" == "$filename" ]; then
        wlr-warn "update: failed to match filename $filename against expected subdirectory"
        continue
    fi
    dir="${relative%/*}"
    if [ "$dir" != "$relative" ]; then
        sync_dir "$dir" || continue
    fi
    link_file "$relative"
done 3< <( find -L "$WLR_ENV_PATH/dotfiles" -type f 2>/dev/null || true )

touch "$WLR_ENV_PATH/meta/.last-update-check"
wlr-good 'update succeeded'
